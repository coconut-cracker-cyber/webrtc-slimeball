<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WebRTC Basketball 2.5D - Physik Update</title>
    
    <!-- Externe Bibliotheken für QR-Code und WebRTC (PeerJS) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #222;
            color: white;
            touch-action: none; /* Verhindert Zoom auf Mobile */
        }

        /* Styles für den Desktop/Main Screen */
        #game-screen {
            display: none;
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #canvas {
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F7FA 100%); /* Himmel Verlauf */
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            pointer-events: none; /* Klicks gehen durch */
        }

        #qrcode {
            margin-top: 10px;
            background: white;
            padding: 10px;
            display: inline-block;
        }

        /* Styles für den Handy Controller */
        #controller-screen {
            display: none;
            width: 100vw;
            height: 100vh;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #333;
            text-align: center;
        }

        .btn {
            background: #ff9800;
            color: white;
            border: none;
            padding: 20px 40px;
            font-size: 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .btn:active {
            transform: scale(0.95);
        }

        #status {
            margin-top: 20px;
            color: #aaa;
        }

        .ball-preview {
            width: 100px;
            height: 100px;
            background: orange;
            border-radius: 50%;
            margin-bottom: 50px;
            border: 2px solid #fff;
            transition: transform 0.1s; /* Weiche Animation für Feedback */
        }
    </style>
</head>
<body>

    <!-- DESKTOP GAME SCREEN -->
    <div id="game-screen">
        <canvas id="canvas"></canvas>
        <div id="ui-layer">
            <h1>Streetball 2.5D - Physics Pro</h1>
            <p>Punkte: <span id="score">0</span></p>
            <p>Scanne, um beizutreten:</p>
            <div id="qrcode"></div>
            <p style="font-size: 0.8rem; margin-top:5px;">Status: <span id="desktop-status">Warte auf Verbindung...</span></p>
            <p style="font-size: 0.7rem; color:#ccc">Tipp: Halte das Handy senkrecht für hohe Würfe, flach für flache Pässe.</p>
        </div>
    </div>

    <!-- MOBILE CONTROLLER SCREEN -->
    <div id="controller-screen">
        <div class="ball-preview" id="visual-feedback"></div>
        <h2>Controller</h2>
        <p>Halte das Handy wie einen Ball.</p>
        <p>Ziel mit Neigung (Hoch/Runter/Links/Rechts)</p>
        <p>Mache eine Wurfbewegung nach vorne!</p>
        
        <!-- iOS benötigt einen Button für Sensor-Rechte -->
        <button class="btn" id="btn-connect">Starten / Sensoren aktivieren</button>
        <p id="status">Nicht verbunden</p>
        <div id="debug" style="font-size: 0.7rem; color: #555; margin-top: 20px;"></div>
    </div>

    <script>
        // --- KONFIGURATION ---
        // Wir nutzen PeerJS Cloud Server für das WebRTC Handshake
        const peerConfig = {
            debug: 2
        };

        // URL Parameter prüfen um Modus zu bestimmen
        const urlParams = new URLSearchParams(window.location.search);
        const mode = urlParams.get('mode'); // 'controller' oder null (desktop)
        const hostId = urlParams.get('id'); // ID des Desktops

        // --- LOGIK WEICHE ---
        if (mode === 'controller' && hostId) {
            initController(hostId);
        } else {
            initGame();
        }

        // ==========================================
        // TEIL 1: DESKTOP / GAME LOGIC
        // ==========================================
        function initGame() {
            document.getElementById('game-screen').style.display = 'block';
            
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            let score = 0;
            let width, height;
            
            // PeerJS Setup
            const peer = new Peer(null, peerConfig);
            let conn = null;

            peer.on('open', (id) => {
                console.log('Meine Peer ID ist: ' + id);
                
                // QR Code generieren
                const joinUrl = `${window.location.href.split('?')[0]}?mode=controller&id=${id}`;
                new QRCode(document.getElementById("qrcode"), {
                    text: joinUrl,
                    width: 128,
                    height: 128
                });
            });

            peer.on('connection', (c) => {
                conn = c;
                document.getElementById('desktop-status').innerText = "Controller verbunden!";
                document.getElementById('desktop-status').style.color = "#0f0";

                // Daten vom Handy empfangen
                conn.on('data', (data) => {
                    if (data.type === 'throw') {
                        // Hier kommen die rohen Sensordaten an.
                        // data.force: Gesamtkraft des Wurfs (Beschleunigung)
                        // data.beta: Neigung Vor/Zurück (-180 bis 180)
                        // data.gamma: Neigung Links/Rechts (-90 bis 90)
                        spawnBall(data.force, data.beta, data.gamma);
                    }
                });
            });

            // Spiel-Objekte
            const balls = [];
            // Korb Definition: Z ist die Tiefe (500 Einheiten weg)
            const hoop = { x: 0, y: 0, width: 120, height: 10, z: 500 }; 

            // Resize Handler
            function resize() {
                width = window.innerWidth;
                height = window.innerHeight;
                canvas.width = width;
                canvas.height = height;
                // Korb positionieren
                hoop.x = width / 2;
                hoop.y = height * 0.35; 
            }
            window.addEventListener('resize', resize);
            resize();

            /**
             * Erstellt einen Ball basierend auf den physikalischen Parametern des Wurfs.
             * Implementiert die "Gravity Penalty" und winkelabhängige Geschwindigkeit.
             */
            function spawnBall(force, beta, gamma) {
                // 1. FIX LINKS/RECHTS: 
                // Gamma ist die Neigung nach rechts. 
                // Vorher war es reversed, also multiplizieren wir mit -1 (bzw. negativer Faktor).
                // Ein Faktor von 0.5 dämpft die Seitwärtsbewegung etwas, damit man leichter zielt.
                const velocityX = gamma * -0.4; 

                // 2. WINKEL BESTIMMUNG (HOCH/RUNTER):
                // Beta ist die Neigung des Handys.
                // ~90 Grad: Handy steht aufrecht (Wurf nach oben/vorne)
                // ~0 Grad: Handy liegt flach (Wurf nach unten/vorne)
                // Wir definieren einen "Neutralpunkt" bei ca. 45 Grad.
                // Alles über 45 Grad wirft nach oben (Y-Velocity negativ im Canvas), alles darunter flach/runter.
                // Wir normalisieren das grob auf einen Faktor zwischen -1 (sehr flach) und 1 (sehr steil).
                const angleFactor = (beta - 45) / 45; 

                // 3. SCHWERKRAFT-LOGIK ("Gravity Penalty"):
                // Der Prompt verlangt: "throwing upwards takes more force since gravity is pulling".
                // Wenn angleFactor > 0 (Wurf nach oben), reduzieren wir die effektive Kraft.
                let effectiveForce = force;
                if (angleFactor > 0) {
                    // Je steiler der Wurf, desto mehr Kraft geht "verloren" um gegen die Schwerkraft anzukommen.
                    // Wir ziehen hier pauschal einen Wert ab, skaliert mit der Steilheit.
                    const gravityDrag = angleFactor * 5; 
                    effectiveForce = Math.max(force - gravityDrag, 0); // Kraft kann nicht negativ sein
                }

                // 4. AUFTEILUNG DER KRAFT (Vektoren):
                // Wir teilen die 'effectiveForce' auf in Geschwindigkeit nach oben (Y) und in die Tiefe (Z).
                
                // Z-Geschwindigkeit (Tiefe):
                // Wenn wir sehr steil nach oben werfen (hoher angleFactor), geht weniger Energie in die Tiefe.
                // Wir nutzen Cosinus-ähnliche Annäherung: (1 - abs(angleFactor) * 0.5)
                const velocityZ = effectiveForce * 1.5 * (1 - Math.abs(angleFactor) * 0.3);

                // Y-Geschwindigkeit (Höhe):
                // Negativ = Nach oben im Canvas.
                // Wir multiplizieren die Kraft mit dem Winkelfaktor.
                // Ein starker Wurf (viel Force) bei steilem Winkel (hoher angleFactor) gibt viel Upward-Velocity.
                const velocityY = -1 * effectiveForce * angleFactor * 2.5;

                // Ball Objekt erstellen
                balls.push({
                    x: width / 2,       // Startet unten mittig
                    y: height, 
                    z: 0,               // Startet "ganz vorne" (Z=0)
                    vx: velocityX,      // Seitliche Drift
                    vy: velocityY,      // Vertikale Geschwindigkeit (berechnet mit Schwerkraft-Penalty)
                    vz: velocityZ,      // Tiefengeschwindigkeit
                    radius: 40,         // Startradius in Pixeln
                    color: 'orange',
                    scored: false
                });
            }

            function update() {
                ctx.clearRect(0, 0, width, height);

                // --- HINTERGRUND & KORB (2.5D) ---
                // Je größer Z, desto kleiner wird alles (Perspektive)
                const focalLength = 800; // "Brennweite" der Kamera
                const depthScale = focalLength / (focalLength + hoop.z);
                
                const hW = hoop.width * depthScale;
                const hX = hoop.x - hW / 2;
                const hY = hoop.y;
                
                // Backboard zeichnen
                ctx.fillStyle = "white";
                ctx.fillRect(hX - 20 * depthScale, hY - 80 * depthScale, hW + 40 * depthScale, 80 * depthScale);
                ctx.strokeStyle = "red";
                ctx.strokeRect(hX + hW*0.3, hY - 60*depthScale, hW*0.4, 40*depthScale);

                // Ring zeichnen (Ellipse um Tiefe anzudeuten)
                ctx.beginPath();
                ctx.ellipse(hoop.x, hY, hW/2, 10 * depthScale, 0, 0, Math.PI * 2);
                ctx.lineWidth = 5;
                ctx.strokeStyle = "orange";
                ctx.stroke();

                // --- BÄLLE PHYSIK & RENDERING ---
                for (let i = balls.length - 1; i >= 0; i--) {
                    let b = balls[i];

                    // Positions-Update
                    b.x += b.vx;
                    b.y += b.vy;
                    b.z += b.vz;
                    
                    // Physik: Schwerkraft wirkt immer nach unten (erhöht Y)
                    b.vy += 0.5; 
                    
                    // Luftwiderstand (optional, macht es realistischer)
                    b.vz *= 0.99; 

                    // Perspektive berechnen (2.5D Logik wie gefordert)
                    // Formel: scale = focalLength / (focalLength + z)
                    // Z wächst, wenn der Ball wegfliegt -> scale wird kleiner -> Ball wird kleiner
                    const scale = focalLength / (focalLength + b.z);
                    
                    const drawRadius = b.radius * scale;
                    
                    // Wenn Ball unten aus dem Bild fällt -> Löschen
                    if (b.y > height + 200) {
                        balls.splice(i, 1); 
                        continue;
                    }

                    // Ball zeichnen
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, Math.max(drawRadius, 1), 0, Math.PI * 2);
                    ctx.fillStyle = b.color;
                    ctx.fill();
                    ctx.strokeStyle = "#333";
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // --- KOLLISIONSERKENNUNG (Treffer) ---
                    // Wir prüfen, ob der Ball ungefähr die Tiefe des Korbs erreicht hat (Z-Achse)
                    if (!b.scored && Math.abs(b.z - hoop.z) < 50) { 
                         // Wir prüfen, ob der Ball innerhalb des Ring-Radius ist (X-Achse)
                         // und ob er von oben kommt (vy > 0)
                         if (Math.abs(b.x - hoop.x) < (hW/2) && Math.abs(b.y - hoop.y) < 30 && b.vy > 0) {
                             score++; // Punkt!
                             b.scored = true;
                             b.color = "#00ff00"; // Grünes Feedback
                             document.getElementById('score').innerText = score;
                         }
                    }
                }

                requestAnimationFrame(update);
            }

            update();
        }

        // ==========================================
        // TEIL 2: MOBILE CONTROLLER LOGIC
        // ==========================================
        function initController(hostId) {
            document.getElementById('controller-screen').style.display = 'flex';
            const statusEl = document.getElementById('status');
            const btn = document.getElementById('btn-connect');
            const visualBall = document.getElementById('visual-feedback');

            const peer = new Peer(null, peerConfig);
            let conn = null;

            // Verbindung zum Desktop aufbauen
            peer.on('open', (id) => {
                statusEl.innerText = "Verbinde mit Desktop...";
                conn = peer.connect(hostId);

                conn.on('open', () => {
                    statusEl.innerText = "Verbunden! Ausrichtung kalibriert.";
                    statusEl.style.color = "#0f0";
                    btn.innerText = "Neu kalibrieren"; 
                });

                conn.on('error', (err) => {
                    statusEl.innerText = "Fehler: " + err;
                });
            });

            // Variablen für Sensordaten
            let lastAccZ = 0;
            let throwThreshold = 15; // Mindestkraft für einen Wurf (m/s^2)
            let canThrow = true;
            
            // Orientierungs-Variablen
            let tiltLR = 0; // Gamma (Links/Rechts)
            let tiltFB = 0; // Beta (Vorne/Hinten)

            // iOS Permission Handler (Wichtig für Apple Geräte)
            btn.addEventListener('click', () => {
                if (typeof DeviceMotionEvent.requestPermission === 'function') {
                    DeviceMotionEvent.requestPermission()
                        .then(response => {
                            if (response == 'granted') {
                                startSensors();
                            } else {
                                alert("Sensoren müssen erlaubt sein!");
                            }
                        })
                        .catch(console.error);
                } else {
                    // Android braucht keine explizite Permission auf Klick
                    startSensors();
                }
            });

            function startSensors() {
                // DeviceOrientation: Liefert Rotationsdaten (Lage im Raum)
                window.addEventListener('deviceorientation', handleOrientation);
                // DeviceMotion: Liefert Beschleunigungsdaten (Wurfkraft)
                window.addEventListener('devicemotion', handleMotion);
                statusEl.innerText = "Sensoren aktiv. Wirf!";
            }

            function handleOrientation(event) {
                // Wir speichern die aktuelle Lage des Handys
                if(event.gamma) tiltLR = event.gamma; // Neigung links/rechts (-90 bis 90)
                if(event.beta) tiltFB = event.beta;   // Neigung vor/zurück (-180 bis 180)

                // Visuelles Feedback auf dem Handy (Ball bewegt sich mit Neigung)
                // Wir begrenzen die Bewegung visuell etwas
                visualBall.style.transform = `translate(${tiltLR}px, ${tiltFB-45}px)`;
            }

            function handleMotion(event) {
                if (!conn) return;

                // WICHTIG: Wir nutzen 'acceleration' statt 'accelerationIncludingGravity'.
                // Das entfernt die Erdbeschleunigung (9.81 m/s^2), sodass wir nur die
                // tatsächliche Wurfkraft des Nutzers messen.
                const acc = event.acceleration; 
                if (!acc) return;

                // Berechne die Gesamtkraft des Wurfs (Vektorlänge)
                // Wir nutzen Pythagoras über alle 3 Achsen (X, Y, Z)
                const force = Math.sqrt(acc.x*acc.x + acc.y*acc.y + acc.z*acc.z);

                // Wurferkennung
                if (canThrow && force > throwThreshold) {
                    canThrow = false;
                    
                    // Sende alle relevanten Daten an den Desktop
                    conn.send({
                        type: 'throw',
                        force: force,   // Die rohe Kraft
                        gamma: tiltLR,  // Für Links/Rechts Steuerung
                        beta: tiltFB    // Für Hoch/Runter Steuerung & Gravity Penalty
                    });

                    // Visuelles Feedback (Blitz)
                    document.body.style.backgroundColor = "#555";
                    setTimeout(() => { document.body.style.backgroundColor = "#333"; }, 100);

                    // Cooldown (Verhindert Doppelwürfe)
                    setTimeout(() => {
                        canThrow = true;
                    }, 500);
                }
            }
        }
    </script>
</body>
</html>
